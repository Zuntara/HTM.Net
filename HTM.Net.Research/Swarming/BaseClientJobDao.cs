using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Data;
using System.Diagnostics;
using System.Linq;
using HTM.Net.Util;
using log4net;
using Tuple = HTM.Net.Util.Tuple;

namespace HTM.Net.Research.Swarming
{
    // https://github.com/numenta/nupic/blob/afc8dbc00fa858bfa1fde5f73e7b9d4533ce6e31/src/nupic/database/ClientJobsDAO.py
    /// <summary>
    /// This Data Access Object (DAO) is used for creating, managing, and updating
    /// the ClientJobs database. The ClientJobs database is a MySQL database shared by
    /// the UI, Stream Manager (StreamMgr), and the engine. The clients (UI and
    /// StreamMgr) make calls to this DAO to request new jobs (Hypersearch, stream
    /// jobs, model evaluations, etc.) and the engine queries and updates it to manage
    /// and keep track of the jobs and report progress and results back to the
    /// clients.
    /// This class is primarily a collection of static methods that work with the
    /// client jobs database. But, rather than taking the approach of declaring each
    /// method as static, we provide just one static class method that returns a
    /// reference to the (one) ClientJobsDAO instance allocated for the current
    /// process (and perhaps in the future, for the current thread). This approach
    /// gives us the flexibility in the future of perhaps allocating one instance per
    /// thread and makes the internal design a bit more compartmentalized (by enabling
    /// the use of instance variables). Note: This is generally referred to as
    /// the singleton pattern.
    /// A typical call is made in the following manner:
    ///   ClientJobsDAO.get().jobInfo()
    /// If the caller desires, they have the option of caching the instance returned
    /// from ClientJobsDAO.get(), i.e.:
    ///   cjDAO = ClientJobsDAO.get()
    ///   cjDAO.jobInfo()
    ///   cjDAO.jobSetStatus(...)
    /// There are two tables in this database, the jobs table and the models table, as
    /// described below. The jobs table keeps track of all jobs. The models table is
    /// filled in by hypersearch jobs with the results of each model that it
    /// evaluates.
    /// Jobs table. The field names are given as:
    ///     internal mysql field name (public API field name)
    /// field     description
    /// ---------------------------------------------------------------------------
    /// job_id (jobId): Generated by the database when a new job is inserted by a
    ///           client. This is an auto-incrementing ID that is unique among all
    ///           jobs.
    /// client (client): The name of the client (i.e. 'UI', 'StreamMgr', etc.).
    /// client_info (clientInfo): Arbitrary data specified by client.
    /// client_key (clientKey): Foreign key as defined by the client.
    /// cmd_line (cmdLine): Command line to be used to launch each worker process for
    ///           the job.
    /// params (params):   JSON encoded dict of job specific parameters that are
    ///           useful to the worker processes for this job. This field is provided
    ///           by the client when it inserts the job and can be fetched out of the
    ///           database by worker processes (based on job_id) if needed.
    /// job_hash (jobHash): hash of the job, provided by the client, used for
    ///           detecting identical jobs when they use the jobInsertUnique() call.
    ///           Clients that don't care about whether jobs are unique or not do not
    ///           have to generate or care about this field.
    /// status (status):   The engine will periodically update the status field as the
    ///           job runs.
    ///           This is an enum. Possible values are:
    ///             STATUS_NOTSTARTED   client has just added this job to the table
    ///             STATUS_STARTING:    a CJM is in the process of launching this job in the
    ///                                  engine
    ///             STATUS_RUNNING:     the engine is currently running this job
    ///             STATUS_TESTMODE:    the job is being run by the test framework
    ///                                   outside the context of hadoop, should be
    ///                                   ignored
    ///             STATUS_COMPLETED:   the job has completed. The completion_reason
    ///                                   field describes the manner in which it
    ///                                   completed
    /// completion_reason (completionReason): Why this job completed.  Possible values
    ///           are:
    ///             CMPL_REASON_SUCCESS:  job completed successfully
    ///             CMPL_REASON_KILLED:   job was killed by ClientJobManager
    ///             CMPL_REASON_CANCELLED:  job was cancelled by user
    ///             CMPL_REASON_ERROR:    job encountered an error. The completion_msg
    ///                                 field contains a text description of the error
    /// completion_msg (completionMsg): Text description of error that occurred if job
    ///           terminated with completion_reason of CMPL_REASON_ERROR or
    ///           CMPL_REASON_KILLED
    /// worker_completion_msg (workerCompletionMsg): Why this job completed, according
    ///           to the worker(s).
    /// cancel (cancel):   Set by the clent if/when it wants to cancel a job.
    ///           Periodically polled by the CJM and used as a signal to kill the job.
    ///           TODO: the above claim doesn't match current reality: presently,
    ///                 Hypersearch and Production workers poll the cancel field.
    /// start_time (startTime): date and time of when this job started.
    /// end_time (endTime): date and time of when this job completed.
    /// results (results): A JSON encoded dict of the results of a hypersearch job.
    ///                   The dict contains the following fields. Note that this dict
    ///                   is NULL before any model has reportedits results:
    ///             bestModel: The modelID of the best performing model so far
    ///             bestValue: The value of the optimized metric for the best model
    /// _eng_last_update_time (engLastUpdateTime):  Time stamp of last update. Used
    ///           for detecting stalled jobs.
    /// _eng_cjm_conn_id (engCjmConnId):  The database client connection ID of the CJM
    ///           (Client Job Manager) starting up this job. Set and checked while the
    ///           job is in the 'starting' phase. Used for detecting and dealing with
    ///           stalled CJM's
    /// _eng_worker_state (engWorkerState): JSON encoded data structure
    ///           for private use by the workers.
    /// _eng_status (engStatus): String used to send status messages from the engine
    ///           to the UI. For informative purposes only.
    /// _eng_model_milestones (engModelMilestones): JSON encoded object with
    ///           information about global model milestone results.
    /// minimum_workers (minimumWorkers): min number of desired workers at a time.
    ///           If 0, no workers will be allocated in a crunch
    /// maximum_workers (maximumWorkers): max number of desired workers at a time. If
    ///           0, then use as many as practical given load on the cluster.
    /// priority (priority): job scheduling priority; 0 is the default priority (
    ///           ClientJobsDAO.DEFAULT_JOB_PRIORITY); positive values are higher
    ///           priority (up to ClientJobsDAO.MAX_JOB_PRIORITY), and negative values
    ///           are lower priority (down to ClientJobsDAO.MIN_JOB_PRIORITY)
    /// _eng_allocate_new_workers (engAllocateNewWorkers): Should the scheduling
    ///           algorithm allocate new workers to this job? If a specialized worker
    ///           willingly gives up control, we set this field to FALSE to avoid
    ///           allocating new workers.
    /// _eng_untended_dead_workers (engUntendedDeadWorkers): If a specialized worker
    ///           fails or is killed by the scheduler, we set this feild to TRUE to
    ///           indicate that the worker is dead.
    /// num_failed_workers (numFailedWorkers): The number of failed specialized workers
    ///          for this job. if the number of failures is greater than
    ///          max.failed.attempts, we mark the job as failed
    /// last_failed_worker_error_msg (lastFailedWorkerErrorMsg): Error message of the
    ///          most recent failed specialized worker
    /// Models table: field     description
    /// ---------------------------------------------------------------------------
    /// model_id (modelId):  Generated by the database when the engine inserts a new
    ///             model. This is an auto-incrementing ID that is globally unique
    ///             among all models of all jobs.
    /// job_id (jobId) : The job_id of the job in the Jobs Table that this model
    ///             belongs to.
    /// params (params):    JSON encoded dict of all the parameters used to generate
    ///           this particular model. The dict contains the following properties:
    ///                 paramValues     = modelParamValuesDict,
    ///                 paramLabels     = modelParamValueLabelsDict,
    ///                 experimentName  = expName
    /// status (status):    Enumeration of the model's status. Possible values are:
    ///               STATUS_NOTSTARTED: This model's parameters have been chosen, but
    ///                                   no worker is evaluating it yet.
    ///               STATUS_RUNNING:    This model is currently being evaluated by a
    ///                                   worker
    ///               STATUS_COMPLETED:  This model has finished running. The
    ///                                   completion_reason field describes why it
    ///                                   completed.
    /// completion_reason (completionReason) : Why this model completed.  Possible
    ///           values are:
    ///             CMPL_REASON_EOF:      model reached the end of the dataset
    ///             CMPL_REASON_STOPPED:  model stopped because it reached maturity
    ///                                     and was not deemed the best model.
    ///             CMPL_REASON_KILLED:   model was killed by the terminator logic
    ///                                     before maturing and before reaching EOF
    ///                                     because it was doing so poorly
    ///             CMPL_REASON_ERROR:    model encountered an error. The completion_msg
    ///                                     field contains a text description of the
    ///                                     error
    /// completion_msg (completionMsg): Text description of error that occurred if
    ///           model terminated with completion_reason of CMPL_REASON_ERROR or
    ///           CMPL_REASON_KILLED
    /// results (results):  JSON encoded structure containing the latest online
    ///           metrics produced by the model. The engine periodically updates this
    ///           as the model runs.
    /// optimized_metric(optimizedMetric): The value of the metric over which
    ///         this model is being optimized. Stroring this separately in the database
    ///         allows us to search through to find the best metric faster
    /// update_counter (updateCounter): Incremented by the UI whenever the engine
    ///           updates the results field. This makes it easier and faster for the
    ///           UI to determine which models have changed results.
    /// num_records (numRecords):  Number of records (from the original dataset,
    ///           before aggregation) that have been processed so far by this model.
    ///           Periodically updated by the engine as the model is evaluated.
    /// start_time (startTime): Date and time of when this model started being
    ///           evaluated.
    /// end_time (endTime): Date and time of when this model completed.
    /// cpu_time (cpuTime): How much actual CPU time was spent evaluating this
    ///           model (in seconds). This excludes any time the process spent
    ///           sleeping, or otherwise not executing code.
    /// model_checkpoint_id (modelCheckpointId): Checkpoint identifier for this model
    ///           (after it has been saved)
    /// _eng_params_hash (engParamsHash): MD5 hash of the params. Used for detecting
    ///           duplicate models.
    /// _eng_particle_hash (engParticleHash): MD5 hash of the model's particle (for
    ///           particle swarm optimization algorithm).
    /// _eng_last_update_time (engLastUpdateTime):  Time stamp of last update. Used
    ///           for detecting stalled workers.
    /// _eng_task_tracker_id (engTaskTrackerId):  ID of the Hadoop Task Tracker
    ///           managing the worker
    /// _eng_worker_id (engWorkerId): ID of the Hadoop Map Task (worker) for this task
    /// _eng_attempt_id (engAttemptId):  Hadoop attempt ID of this task attempt
    /// _eng_worker_conn_id (engWorkerConnId): database client connection ID of the
    ///           hypersearch worker that is running this model
    /// _eng_milestones (engMilestones): JSON encoded list of metric values for the
    ///           model at each milestone point.
    /// _eng_stop (engStop): One of the STOP_REASON_XXX enumerated value strings
    ///           (or None). This gets set to STOP_REASON_KILLED if the terminator
    ///           decides that the performance of this model is so poor that it
    ///           should be terminated immediately. This gets set to STOP_REASON_STOPPED
    ///           if Hypersearch decides that the search is over and this model
    ///           doesn't have to run anymore.
    /// _eng_matured (engMatured): Set by the model maturity checker when it decides
    ///           that this model has "matured".
    /// </summary>
    public class BaseClientJobDao
    {
        public const int MIN_JOB_PRIORITY = -100;          // Minimum job scheduling priority
        public const int DEFAULT_JOB_PRIORITY = 0;         // Default job scheduling priority
        public const int MAX_JOB_PRIORITY = 100;           // Maximum job scheduling priority

        public const string STATUS_NOTSTARTED = "notStarted";
        public const string STATUS_STARTING = "starting";
        public const string STATUS_RUNNING = "running";
        public const string STATUS_TESTMODE = "testMode";
        public const string STATUS_COMPLETED = "completed";

        public const string JOB_TYPE_HS = "hypersearch";
        public const string JOB_TYPE_PM = "production-model";
        public const string JOB_TYPE_SM = "stream-manager";
        public const string JOB_TYPE_TEST = "test";

        public const string STOP_REASON_KILLED = "killed";
        public const string STOP_REASON_STOPPED = "stopped";

        public const string CMPL_REASON_ORPHAN = "orphan";
        public const string CMPL_REASON_KILLED = "killed";
        public const string CMPL_REASON_ERROR = "error";
        public const string CMPL_REASON_EOF = "eof";
        public const string CMPL_REASON_CANCELLED = "cancel";
        public const string CMPL_REASON_STOPPED = "stopped";
        public const string CMPL_REASON_SUCCESS = "success";

        protected readonly ILog _logger = LogManager.GetLogger(typeof(BaseClientJobDao));
        protected string jobsTableName = "Jobs";


        /// <summary>
        ///  Change the value of 1 field in a job to 'newValue', but only if the
        /// current value matches 'curValue'. The 'fieldName' is the public name of
        /// the field(camelBack, not the lower_case_only form as stored in the DB).
        /// This method is used for example by HypersearcWorkers to update the
        /// engWorkerState field periodically.By qualifying on curValue, it insures
        /// that only 1 worker at a time is elected to perform the next scheduled
        /// periodic sweep of the models.
        /// </summary>
        /// <param name="jobID">jobID of the job record to modify</param>
        /// <param name="fieldName">public field name of the field</param>
        /// <param name="curValue">current value to qualify against</param>
        /// <param name="newValue">new value of the field to set</param>
        /// <returns>True if we successfully modified the field False if curValue did not match</returns>
        public virtual bool jobSetFieldIfEqual(uint? jobID, string fieldName, string newValue, string curValue)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Fetch the values of 1 or more fields from a job record. Here, 'fields'
        /// is a list with the names of the fields to fetch.The names are the public
        /// names of the fields(camelBack, not the lower_case_only form as stored in
        /// the DB).
        /// Parameters:
        /// ----------------------------------------------------------------
        /// jobID:      jobID of the job record
        /// fields:     list of fields to return
        /// Returns:    A sequence of field values in the same order as the requested
        ///             field list -> [field1, field2, ...]
        /// </summary>
        /// <param name="jobId"></param>
        /// <param name="fields"></param>
        /// <returns>A list of tuples->(jobID, [field1, field2,...])</returns>
        public List<object> jobGetFields(uint? jobId, string[] fields)
        {
            return jobGetFields(jobId, fields, true);
        }
        public virtual List<object> jobGetFields(uint? jobId, string[] fields, bool requireAll)
        {
            throw new NotImplementedException();
        }

        public virtual ulong? modelAdoptNextOrphan(uint? jobId, double modelOrphanIntervalSecs)
        {
            throw new NotImplementedException();
        }

        public virtual void modelSetCompleted(ulong? modelID, string completionReason, string completionMsg, long? cpuTime = null)
        {
            throw new NotImplementedException();
        }

        public virtual void modelSetFields(ulong? modelID, Dictionary<string, object> fields, bool? ignoreUnchanged = null)
        {
            throw new NotImplementedException();
        }

        public virtual void jobSetFields(uint? jobID, Dictionary<string, object> fields, bool useConnectionID, bool ignoreUnchanged)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Return info on all of the models that are in already in the models
        /// table for a given job.For each model, this returns a tuple
        /// containing: (modelID, updateCounter).
        /// 
        /// Note that we don't return the results for all models, since the results
        /// string could be quite large.The information we are returning is
        /// just 2 integer fields.
        /// </summary>
        /// <param name="jobId"></param>
        /// <returns></returns>
        public virtual List<Tuple<ulong, uint>> modelsGetUpdateCounters(uint? jobId)
        {
            throw new NotImplementedException();
        }

        public static BaseClientJobDao Create()
        {
            return new MemoryClientJobDao();
        }

        // used for workerId
        public virtual string getConnectionID()
        {
            throw new NotImplementedException();
        }

        public virtual void modelsClearAll()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Add an entry to the jobs table for a new job request. This is called by
        /// clients that wish to startup a new job, like a Hypersearch, stream job, or
        /// specific model evaluation from the engine.
        /// This puts a new entry into the jobs table.The CJM is always periodically
        /// sweeping the jobs table and when it finds a new job, will proceed to start it
        /// up on Hadoop.
        /// </summary>
        /// <param name="client">Name of the client submitting the job</param>
        /// <param name="cmdLine">Command line to use to launch each worker process; must be a non-empty string</param>
        /// <param name="clientInfo">JSON encoded dict of client specific information.</param>
        /// <param name="clientKey">Foreign key.</param>
        /// <param name="params">JSON encoded dict of the parameters for the job. 
        /// This can be fetched out of the database by the worker processes based on the jobID.</param>
        /// <param name="alreadyRunning">Used for unit test purposes only. This inserts the job
        /// in the running state.It is used when running a worker
        /// in standalone mode without hadoop - it gives it a job
        /// record to work with.</param>
        /// <param name="minimumWorkers">minimum number of workers design at a time.</param>
        /// <param name="maximumWorkers">maximum number of workers desired at a time.</param>
        /// <param name="jobType">The type of job that this is. This should be one of the
        /// JOB_TYPE_XXXX enums.This is needed to allow a standard
        /// way of recognizing a job's function and capabilities.</param>
        /// <returns>jobID - unique ID assigned to this job</returns>
        public virtual uint jobInsert(string client, string cmdLine, string clientInfo = "", string clientKey = "",
            string @params = "", bool alreadyRunning = false, int minimumWorkers = 0, int maximumWorkers = 0,
            string jobType = "")
        {
            string jobHash = this._normalizeHash(Guid.NewGuid().ToString());

            Func<uint> insertWithRetries = () =>
            {
                IDbConnection conn = null;
                return this._insertOrGetUniqueJobNoRetries(
                    connection: conn, client: client, cmdLine: cmdLine, jobHash: jobHash,
                    clientInfo: clientInfo, clientKey: clientKey, @params: @params,
                    minimumWorkers: minimumWorkers, maximumWorkers: maximumWorkers,
                    jobType: jobType, alreadyRunning: alreadyRunning);
            };
            uint jobID;
            try
            {
                jobID = insertWithRetries();
            }
            catch
            {
                this._logger.Fatal(string.Format("jobInsert FAILED: jobType={0}; client={1}; clientInfo={2}; clientKey={3}; jobHash={4}; cmdLine={5}",
                    jobType, client, _abbreviate(clientInfo, 48), clientKey, jobHash, cmdLine));
                throw;
            }

            this._logger.Info(string.Format(
                "jobInsert: returning jobID={0}. jobType={1}; client={2}; clientInfo={3}; clientKey={4}; jobHash={5}; cmdLine={6}"
                , jobID, jobType, client, _abbreviate(clientInfo, 48), clientKey, jobHash, cmdLine));

            return jobID;
        }

        private uint _insertOrGetUniqueJobNoRetries(IDbConnection connection, string client, string cmdLine, string jobHash,
            string clientInfo, string clientKey, string @params, int minimumWorkers, int maximumWorkers, string jobType,
            bool alreadyRunning)
        {
            //Debug.Assert(client.Length <= CLIENT_MAX_LEN, "client too long:" + repr(client);
            //Debug.Assert(cmdLine != null, "Unexpected empty or None command-line: " + repr(cmdLine);
            //Debug.Assert(jobHash.Length == HASH_MAX_LEN, "wrong hash len=%d" % len(jobHash);
            string initStatus;
            // Initial status
            if (alreadyRunning)
            {
                // STATUS_TESTMODE, so that scheduler won't pick it up (for in-proc tests)
                initStatus = STATUS_TESTMODE;
            }
            else
            {
                initStatus = STATUS_NOTSTARTED;
            }

            // Create a new job entry
            string query = "INSERT IGNORE INTO " + this.jobsTableName + " (status, client, client_info, client_key," +
                           "cmd_line, params, job_hash, _eng_last_update_time, " +
                           "minimum_workers, maximum_workers, priority, _eng_job_type) " +
                           " VALUES (%%s, %%s, %%s, %%s, %%s, %%s, %%s, " +
                           "         UTC_TIMESTAMP(), %%s, %%s, %%s, %%s) ";

            //var command = connection.CreateCommand();
            //command.CommandText = query;
            //// TODO: add parameters
            //int numRowsInserted = command.ExecuteNonQuery();
            int numRowsInserted = 1;
            //sqlParams = (initStatus, client, clientInfo, clientKey, cmdLine, params,
            //             jobHash, minimumWorkers, maximumWorkers, priority, jobType);
            //numRowsInserted = conn.cursor.execute(query, sqlParams);

            uint jobID = 1;

            if (numRowsInserted == 1)
            {
                // Get the chosen job id
                // NOTE: LAST_INSERT_ID() returns 0 after intermittent connection failure
                //conn.cursor.execute("SELECT LAST_INSERT_ID()");
                //jobID = conn.cursor.fetchall()[0][0];
                if (jobID == 0)
                {
                    this._logger.Warn(string.Format(
                      "_insertOrGetUniqueJobNoRetries: SELECT LAST_INSERT_ID() returned 0; " +
                      "likely due to reconnection in SteadyDB following INSERT. " +
                      "jobType={0}; client={1}; clientInfo={2}; clientKey={3}; jobHash={4}; " +
                      "cmdLine={5}",
                      jobType, client, _abbreviate(clientInfo, 32), clientKey, jobHash,
                      cmdLine));
                }
            }
            else
            {
                // Assumption: nothing was inserted because this is a retry and the row
                // with this client/hash already exists from our prior
                // partially-successful attempt; or row with matching client/jobHash was
                // inserted already by some process on some machine.
                Debug.Assert(numRowsInserted == 0, numRowsInserted.ToString());
            }

            if (jobID == 0)
            {
                // Recover from intermittent failure in a partially-successful attempt;
                // or row with matching client/jobHash was already in table
                //row = this._getOneMatchingRowNoRetries(
                //  this._jobs, conn, dict(client = client, job_hash = jobHash), ['job_id']);
                //assert row is not None;
                //assert len(row) == 1, 'Unexpected num fields: ' + repr(len(row));
                //jobID = row[0];
                throw new NotImplementedException("check above");
            }

            // ---------------------------------------------------------------------
            // If asked to enter the job in the running state, set the connection id
            //  and start time as well
            if (alreadyRunning)
            {
                query = "UPDATE " + this.jobsTableName + " SET _eng_cjm_conn_id=%%s, " +
              "              start_time=UTC_TIMESTAMP(), " +
              "              _eng_last_update_time=UTC_TIMESTAMP() " +
              "          WHERE job_id=%%s";
                //conn.cursor.execute(query, (this._connectionID, jobID));
            }

            return jobID;
        }

        public bool jobUpdateSelectionSweep(uint jobId, int minUpdateInterval)
        {
            throw new NotImplementedException();
        }

        public void jobUpdateResults(uint jobId, string o)
        {
            throw new NotImplementedException();
        }

        public Tuple modelsGetCandidates(uint jobId, int minUpdateRecords)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Get the results string and other status fields for a set of models.
        /// 
        /// WARNING!!!: The order of the results are NOT necessarily in the same order
        /// as the order of the model IDs passed in!!!
        /// 
        /// For each model, this returns a tuple containing:
        /// (modelID, results, status, updateCounter, numRecords, completionReason,completionMsg, engParamsHash)
        /// 
        /// </summary>
        /// <param name="modelIDs">list of model IDs</param>
        /// <returns>list of result tuples. Each tuple contains: 
        ///  (modelID, results, status, updateCounter, numRecords, completionReason, completionMsg, engParamsHash)
        /// </returns>
        public virtual List<ResultAndStatusModel> modelsGetResultAndStatus(IEnumerable<ulong> modelIDs)
        {
            Debug.Assert(modelIDs.Count() >= 1, "modelIDs is empty");

            //var rows = this._getMatchingRowsWithRetries(_models, { 'model_id' : modelIDs},
            //     [self._models.pubToDBNameDict[f] for f in self._models.getResultAndStatusNamedTuple._fields])

            // NOTE: assertion will also fail when modelIDs contains duplicates
            //Debug.Assert(rows.Count == modelIDs.Count, "Didn't find modelIDs", "Didn't find modelIDs: %r", 
            //    (set(modelIDs) - set(r[0] for r in rows)),)

            // Return the results as a list of namedtuples
            //return [self._models.getResultAndStatusNamedTuple._make(r) for r in rows]
            throw new NotImplementedException();
        }

        /// <summary>
        /// Get all info about a job
        /// </summary>
        /// <param name="jobId">jobID of the job to query</param>
        /// <returns>namedtuple containing the job info.</returns>
        public virtual NamedTuple jobInfo(uint? jobId)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Insert a new unique model (based on params) into the model table in the
        /// "running" state.This will return two things: whether or not the model was
        /// actually inserted(i.e.that set of params isn't already in the table) and
        /// the modelID chosen for that set of params. Even if the model was not
        /// inserted by this call (it was already there) the modelID of the one already
        /// inserted is returned.
        /// </summary>
        /// <param name="jobId">jobID of the job to add models for</param>
        /// <param name="params">params for this model</param>
        /// <param name="paramsHash"> hash of the params, generated by the worker</param>
        /// <param name="particleHash">ash of the particle info (for PSO). If not provided, then paramsHash will be used.</param>
        /// <returns>(modelID, wasInserted)
        ///  modelID: the model ID for this set of params
        /// wasInserted: True if this call ended up inserting the
        /// new model.False if this set of params was already in
        /// the model table.
        /// </returns>
        public virtual Tuple<ulong, bool> modelInsertAndStart(uint? jobId, string @params, string paramsHash, string particleHash = null)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Get the params and paramsHash for a set of models.
        /// </summary>
        /// <param name="newModelIDs">list of model IDs</param>
        /// <returns>
        /// list of result namedtuples defined in ClientJobsDAO._models.getParamsNamedTuple.
        /// Each tuple contains: (modelId, params, engParamsHash)
        /// </returns>
        public virtual List<NamedTuple> modelsGetParams(List<ulong> newModelIDs)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="modelIDs">A single modelID or sequence of modelIDs</param>
        /// <param name="fields">A list  of fields to return</param>
        /// <returns>
        /// If modelIDs is a sequence: a list of tuples->(modelID, [field1, field2,...])
        /// If modelIDs is a single modelID:  a list of field values->[field1, field2,...]
        /// </returns>
        public virtual Map<ulong, ModelTable> modelsGetFields(ulong[] modelIDs, string[] fields)
        {
            throw new NotImplementedException();
        }

        public ModelTable modelsGetFields(ulong modelID, string[] fields)
        {
            Map<ulong, ModelTable> list = modelsGetFields(new[] { modelID }, fields);
            var first = list.First();
            return first.Value;
        }

        public void jobSetCompleted(uint? jobID, string completionReason, string completionMsg)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Abbreviate the given text to threshold chars and append an ellipsis if its
        /// length exceeds threshold; used for logging;
        /// 
        /// NOTE: the resulting text could be longer than threshold due to the ellipsis
        /// </summary>
        /// <param name="text"></param>
        /// <param name="threshold"></param>
        /// <returns></returns>
        protected string _abbreviate(string text, int threshold)
        {
            if (text != null && text.Length > threshold)
            {
                text = text.Substring(0, threshold) + "...";
            }
            return text;
        }

        protected const int HASH_MAX_LEN = 16 * 2;
        protected const int CLIENT_MAX_LEN = 8;
        protected string _normalizeHash(string hashValue)
        {
            int hashLen = hashValue.Length;
            if (hashLen < HASH_MAX_LEN)
            {
                hashValue.PadRight(HASH_MAX_LEN, '\0');
                //hashValue +=  '\0' * (HASH_MAX_LEN - hashLen);
            }
            else
            {
                Debug.Assert(hashLen <= HASH_MAX_LEN, string.Format("Hash is too long: hashLen={0}; hashValue={1}", hashLen, hashValue));
            }

            return hashValue;
        }

        public virtual void modelUpdateResults(ulong? modelId, string results = null, double? metricValue = null, uint? numRecords = null)
        {
            throw new NotImplementedException();
        }

        public virtual void modelUpdateTimestamp(ulong? modelId)
        {
            throw new NotImplementedException();
        }

        public virtual List<ModelTable> modelsInfo(List<ulong> modelIDs)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Fetch all the modelIDs that correspond to a given jobID; empty sequence if none
        /// </summary>
        /// <param name="jobId"></param>
        /// <returns></returns>
        public virtual List<ulong> jobGetModelIDs(uint? jobId)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Gets the specified fields for all the models for a single job. This is similar to modelsGetFields
        /// </summary>
        /// <param name="jobId">jobID for the models to be searched</param>
        /// <param name="fields">A list  of fields to return</param>
        /// <param name="ignoreKilled">(True/False). If True, this will ignore models that have been killed</param>
        /// <returns>
        /// a (possibly empty) list of tuples as follows
        /// [
        ///     (model_id1, [field1, ..., fieldn]),
        ///     (model_id2, [field1, ..., fieldn]),
        ///     (model_id3, [field1, ..., fieldn])
        ///     ...
        /// ]
        /// 
        /// NOTE: since there is a window of time between a job getting inserted into
        /// jobs table and the job's worker(s) starting up and creating models, an
        /// empty-list result is one of the normal outcomes.
        /// </returns>
        public virtual List<Tuple<ulong?, object[]>> modelsGetFieldsForJob(uint? jobId, string[] fields, bool ignoreKilled = false)
        {
            throw new NotImplementedException();
        }
    }

    public class MemoryClientJobDao : BaseClientJobDao
    {
        private static List<JobTable> Jobs { get; set; }
        private static List<ModelTable> Models { get; set; }

        public MemoryClientJobDao()
        {
            if (Jobs == null) Jobs = new List<JobTable>();
            if (Models == null) Models = new List<ModelTable>();
        }

        #region Overrides of BaseClientJobDao

        public override uint jobInsert(string client, string cmdLine, string clientInfo = "", string clientKey = "", string @params = "",
            bool alreadyRunning = false, int minimumWorkers = 0, int maximumWorkers = 0, string jobType = "")
        {
            string jobHash = this._normalizeHash(Guid.NewGuid().ToString().Replace("-", ""));
            uint jobID = (uint)(Jobs.Count + 1);

            string initStatus;
            // Initial status
            if (alreadyRunning)
            {
                // STATUS_TESTMODE, so that scheduler won't pick it up (for in-proc tests)
                initStatus = STATUS_TESTMODE;
            }
            else
            {
                initStatus = STATUS_NOTSTARTED;
            }

            JobTable table = new JobTable();
            // initStatus, client, clientInfo, clientKey, cmdLine, params,
            //             jobHash, minimumWorkers, maximumWorkers, priority, jobType
            table.jobID = jobID;
            table.status = initStatus;
            table.client = client;
            table.client_info = clientInfo;
            table.client_key = clientKey;
            table.cmd_line = cmdLine;
            table.@params = @params;
            table.job_hash = jobHash;
            table.minimum_workers = minimumWorkers;
            table.maximum_workers = maximumWorkers;
            //table.priority = priority;
            table._eng_job_type = jobType;

            Jobs.Add(table);

            // ---------------------------------------------------------------------
            // If asked to enter the job in the running state, set the connection id
            //  and start time as well
            if (alreadyRunning)
            {
                table.start_time = DateTime.Now;
                table._eng_last_update_time = DateTime.Now;
                //table._eng_cjm_conn_id = this._connectionID;
            }

            this._logger.Info(string.Format(
                "jobInsert: returning jobID={0}. jobType={1}; client={2}; clientInfo={3}; clientKey={4}; jobHash={5}; cmdLine={6}"
                , jobID, jobType, client, _abbreviate(clientInfo, 48), clientKey, jobHash, cmdLine));

            return jobID;
        }

        public override List<object> jobGetFields(uint? jobId, string[] fields, bool requireAll)
        {
            //var rows = this._getMatchingRowsWithRetries(this._jobs, dict(job_id = jobIDs),
            //    ['job_id'] + [this._jobs.pubToDBNameDict[x] for x in fields]) ;


            //if (requireAll && rows.Count < jobIDs.Count)
            //{
            //    // NOTE: this will also trigger if the jobIDs list included duplicates
            //    throw new InvalidOperationException("jobIDs %s not found within the jobs table");
            //    //% ((set(jobIDs) - set(r[0] for r in rows)),));
            //}

            JobTable job = Jobs.First(j => j.jobID == jobId.GetValueOrDefault());

            List<object> results = new List<object>();
            foreach (string field in fields)
            {
                if (field == "workerCompletionReason")
                {
                    results.Add(job.worker_completion_reason);
                }
                else if (field == "cancel")
                {
                    results.Add(job.cancel);
                }
                else if (field == "results")
                {
                    results.Add(job.results);
                }
                else if (field == "engWorkerState")
                {
                    results.Add(job._eng_worker_state);
                }
                else
                {
                    throw new NotImplementedException("field: " + field + "to be mapped");
                }
            }

            // return [(r[0], list(r[1:])) for r in rows];

            return results;
        }

        public override List<Tuple<ulong, uint>> modelsGetUpdateCounters(uint? jobId)
        {
            return Models
                .Where(m => m.job_id == jobId)
                .Select(m => new Tuple<ulong, uint>(m.model_id, m.update_counter)).ToList();
        }

        public override List<ResultAndStatusModel> modelsGetResultAndStatus(IEnumerable<ulong> modelIDs)
        {
            Debug.Assert(modelIDs.Count() >= 1, "modelIDs is empty");

            List<ResultAndStatusModel> rows = _getMatchingRowsWithRetries(Models, m => modelIDs.Contains(m.model_id),
                m => new ResultAndStatusModel
                {
                    modelId = m.model_id,
                    resultsSerialized = m.results,
                    status = m.status,
                    updateCounter = m.update_counter,
                    numRecords = m.num_records,
                    completionReason = m.completion_reason,
                    completionMsg = m.completion_msg,
                    engParamsHash = m._eng_params_hash,
                    engMatured = m._eng_matured
                });

            //var rows = this._getMatchingRowsWithRetries(_models, { 'model_id' : modelIDs},
            //     [self._models.pubToDBNameDict[f] for f in self._models.getResultAndStatusNamedTuple._fields])

            // NOTE: assertion will also fail when modelIDs contains duplicates
            Debug.Assert(rows.Count == modelIDs.Count(), "Didn't find modelIDs");
            //Debug.Assert(rows.Count == modelIDs.Count, "Didn't find modelIDs", "Didn't find modelIDs: %r", 
            //    (set(modelIDs) - set(r[0] for r in rows)),)

            // Return the results as a list of namedtuples
            //return [self._models.getResultAndStatusNamedTuple._make(r) for r in rows]
            return rows;
        }

        public override List<NamedTuple> modelsGetParams(List<ulong> newModelIDs)
        {
            var rows = _getMatchingRowsWithRetries(Models, m => newModelIDs.Contains(m.model_id),
                m => new NamedTuple(new[] {"modelId", "params", "engParamsHash"},
                    new object[] { m.model_id, m.@params, m._eng_params_hash}));

            return rows;
        }

        public override Map<ulong, ModelTable> modelsGetFields(ulong[] modelIDs, string[] fields)
        {
            return new Map<ulong, ModelTable>(
                Models.Where(m => modelIDs.Contains(m.model_id)).ToDictionary(m => m.model_id, m => m));
        }

        public override void modelSetFields(ulong? modelID, Dictionary<string, object> fields, bool? ignoreUnchanged = null)
        {
            var model = Models.Single(m => m.model_id == modelID.Value);

            foreach (var fieldPair in fields)
            {
                if (fieldPair.Key == "engParamsHash")
                {
                    model._eng_params_hash = (string) fieldPair.Value;
                }
                else if (fieldPair.Key == "engParticleHash")
                {
                    model._eng_particle_hash = (string) fieldPair.Value;
                }
                else if (fieldPair.Key == "engStop")
                {
                    model._eng_stop = (string) fieldPair.Value;
                }
                else if (fieldPair.Key == "engWorkerConnId")
                {
                    model._eng_worker_conn_id = (string) fieldPair.Value;
                }
                else if (fieldPair.Key == "modelCheckpointId")
                {
                    model.model_checkpoint_id = (string) fieldPair.Value;
                }
                else if (fieldPair.Key == "genDescription")
                {
                    model.gen_description = (string) fieldPair.Value;
                }
                else
                {
                    throw new InvalidOperationException("Unknown field: " + fieldPair.Key);
                }
            }
            
        }

        public override void jobSetFields(uint? jobID, Dictionary<string, object> fields, bool useConnectionID, bool ignoreUnchanged)
        {
            var job = Jobs.Single(m => m.jobID == jobID.Value);

            foreach (var fieldPair in fields)
            {
                if (fieldPair.Key == "engStatus")
                {
                    job._eng_status = (string)fieldPair.Value;
                }
                else if (fieldPair.Key == "workerCompletionMsg")
                {
                    job.worker_completion_msg = (string) fieldPair.Value;
                }
                else
                {
                    throw new InvalidOperationException("Unknown field: " + fieldPair.Key);
                }
            }
        }

        public override NamedTuple jobInfo(uint? jobId)
        {
            JobTable job = Jobs.FirstOrDefault(j => j.jobID == jobId);
            if (job == null)
            {
                throw new ArgumentOutOfRangeException("jobId", "no such job found");
            }
            return job.ToNamedTuple();
        }

        public override List<ModelTable> modelsInfo(List<ulong> modelIDs)
        {
            var rows = _getMatchingRowsWithRetries(Models, m => modelIDs.Contains(m.model_id), mt=>mt);
            return rows;
        }

        public override string getConnectionID()
        {
            return Guid.NewGuid().ToString().Replace("-", "");
        }

        public override void modelsClearAll()
        {
            Models.Clear();
        }

        /// <summary>
        /// Change the value of 1 field in a job to 'newValue', but only if the
        /// current value matches 'curValue'. The 'fieldName' is the public name of
        /// the field(camelBack, not the lower_case_only form as stored in the DB).
        /// 
        /// This method is used for example by HypersearcWorkers to update the
        /// engWorkerState field periodically.By qualifying on curValue, it insures
        /// that only 1 worker at a time is elected to perform the next scheduled
        /// periodic sweep of the models.
        /// </summary>
        /// <param name="jobId">jobID of the job record to modify</param>
        /// <param name="fieldName">public field name of the field</param>
        /// <param name="newValue">new value of the field to set</param>
        /// <param name="curValue">current value to qualify against</param>
        /// <returns>True if we successfully modified the field False if curValue did not match</returns>
        public override bool jobSetFieldIfEqual(uint? jobId, string fieldName, string newValue, string curValue)
        {
            var job = Jobs.FirstOrDefault(j => j.jobID == jobId);
            if (job == null)
            {
                throw new ArgumentOutOfRangeException("jobId", "no such job found");
            }
            if (fieldName == "genPermutations" && job.gen_permutations == curValue)
            {
                job.gen_permutations = newValue;
                return true;
            }
            if (fieldName == "genBaseDescription" && job.gen_base_description == curValue)
            {
                job.gen_base_description = newValue;
                return true;
            }
            if (fieldName == "results" && job.results == curValue)
            {
                job.results = newValue;
                return true;
            }
            if (fieldName == "engWorkerState" && job._eng_worker_state == curValue)
            {
                job._eng_worker_state = newValue;
                return true;
            }
            throw new InvalidOperationException($"Field {fieldName} to be mapped in jobSetFieldIfEqual");
        }
        /// <summary>
        /// Look through the models table for an orphaned model, which is a model
        /// that is not completed yet, whose _eng_last_update_time is more than
        /// maxUpdateInterval seconds ago.
        /// 
        /// If one is found, change its _eng_worker_conn_id to the current worker's
        /// and return the model id.
        /// </summary>
        /// <param name="jobId"></param>
        /// <param name="maxUpdateInterval"></param>
        /// <returns>modelId of the model we adopted, or None if none found</returns>
        public override ulong? modelAdoptNextOrphan(uint? jobId, double maxUpdateInterval)
        {
            Func<ulong?> findCandidateModelWithRetries = () =>
            {
                var modelEntry = Models.FirstOrDefault(m => m.status == STATUS_RUNNING && m.job_id == jobId
                                  && (DateTime.Now - m._eng_last_update_time).TotalSeconds > maxUpdateInterval);
                return modelEntry != null ? modelEntry.model_id : (ulong?)null;
            };
            Func<ulong?, bool> adoptModelWithRetries = (modelId) =>
            {
                var model = Models.FirstOrDefault(m => m.model_id == modelId && m.status == STATUS_RUNNING);
                Debug.Assert(model != null);
                if (model != null)
                {
                    model._eng_worker_conn_id = this.getConnectionID();
                    model._eng_last_update_time = DateTime.Now;
                }
                return false;
            };

            ulong? adoptedModelID = null;
            while (true)
            {
                ulong? modelID = findCandidateModelWithRetries();
                if (modelID == null)
                {
                    break;
                }
                if (adoptModelWithRetries(modelID))
                {
                    adoptedModelID = modelID;
                    break;
                }
            }

            return adoptedModelID;
        }

        /// <summary>
        /// Insert a new unique model (based on params) into the model table in the
        /// "running" state.This will return two things: whether or not the model was
        /// actually inserted(i.e.that set of params isn't already in the table) and
        /// the modelID chosen for that set of params. Even if the model was not
        /// inserted by this call (it was already there) the modelID of the one already
        /// inserted is returned.
        /// </summary>
        /// <param name="jobId">jobID of the job to add models for</param>
        /// <param name="params">params for this model</param>
        /// <param name="paramsHash"> hash of the params, generated by the worker</param>
        /// <param name="particleHash">ash of the particle info (for PSO). If not provided, then paramsHash will be used.</param>
        /// <returns>(modelID, wasInserted)
        ///  modelID: the model ID for this set of params
        /// wasInserted: True if this call ended up inserting the
        /// new model.False if this set of params was already in
        /// the model table.
        /// </returns>
        public override Tuple<ulong, bool> modelInsertAndStart(uint? jobId, string @params, string paramsHash, string particleHash = null)
        {
            // Fill in default particleHash
            if (particleHash == null)
            {
                particleHash = paramsHash;
            }

            // Normalize hashes
            paramsHash = this._normalizeHash(paramsHash);
            particleHash = this._normalizeHash(particleHash);

            //def findExactMatchNoRetries(conn)
            //{
            //            return this._getOneMatchingRowNoRetries(
            //              this._models, conn,
            //    {
            //                'job_id':jobID, '_eng_params_hash':paramsHash,
            //     '_eng_particle_hash':particleHash},
            //    ['model_id', '_eng_worker_conn_id']);
            //}

            //    def findExactMatchWithRetries()
            //    {
            //# with ConnectionFactory.get() as conn:
            //        def connectionFactoryGet(self);
            //        {
            //            return findExactMatchNoRetries(conn);
            //        }
            //    }

            // Check if the model is already in the models table
            //
            // NOTE: with retries of mysql transient failures, we can't always tell
            //  whether the row was already inserted (e.g., comms failure could occur
            //  after insertion into table, but before arrival or response), so the
            //  need to check before attempting to insert a new row
            //
            // TODO: if we could be assured that the caller already verified the
            //  model's absence before calling us, we could skip this check here
            var row = Models
                .Where(m => m.job_id == jobId && m._eng_params_hash == paramsHash && m._eng_particle_hash == particleHash)
                .Select(m => new { m.model_id, m._eng_worker_conn_id })
                .FirstOrDefault();
            //row = findExactMatchWithRetries();
            if (row != null)
            {
                return new Tuple<ulong, bool>(row.model_id, false);
            }

            // NOTE: it's possible that another process on some machine is attempting
            // to insert the same model at the same time as the caller
            var newModel = new ModelTable();
            newModel.model_id = Models.Any() ? Models.Max(m => m.model_id) + 1 : 1;
            newModel.job_id = jobId.GetValueOrDefault();
            newModel.@params = @params;
            newModel.status = STATUS_RUNNING;
            newModel._eng_params_hash = paramsHash;
            newModel._eng_particle_hash = particleHash;
            newModel.start_time = DateTime.Now;
            newModel._eng_last_update_time = DateTime.Now;
            newModel._eng_worker_conn_id = this.getConnectionID();

            if (Models.Any(m => m.job_id == jobId && m._eng_params_hash == paramsHash && m._eng_particle_hash == particleHash))
            {
                throw new InvalidOperationException("Duplicate entry in model table");
            }

            Models.Add(newModel);


            //def insertModelWithRetries()
            //{
            //    """ NOTE: it's possible that another process on some machine is attempting
            //      to insert the same model at the same time as the caller """;
            //      #with ConnectionFactory.get() as conn:
            //      def connectionFactoryGet(self);
            //    {
            //        // Create a new job entry
            //        query = 'INSERT INTO %s (job_id, params, status, _eng_params_hash, ' \
            //                '  _eng_particle_hash, start_time, _eng_last_update_time, ' \
            //                '  _eng_worker_conn_id) ' \
            //                '  VALUES (%%s, %%s, %%s, %%s, %%s, UTC_TIMESTAMP(), ' \
            //                '          UTC_TIMESTAMP(), %%s) ' \
            //                % (this.modelsTableName,);
            //        sqlParams = (jobID, params, this.STATUS_RUNNING, paramsHash,
            //                     particleHash, this._connectionID);
            //        try
            //        {
            //            numRowsAffected = conn.cursor.execute(query, sqlParams);
            //        }
            //        catch (Exception, e)
            //        {
            //            // NOTE: We have seen instances where some package in the calling
            //            //  chain tries to interpret the exception message using unicode.
            //            //  Since the exception message contains binary data (the hashes), this
            //            //  can in turn generate a Unicode translation exception. So, we catch
            //            //  ALL exceptions here and look for the string "Duplicate entry" in
            //            //  the exception args just in case this happens. For example, the
            //            //  Unicode exception we might get is:
            //            //   (<type 'exceptions.UnicodeDecodeError'>, UnicodeDecodeError('utf8', "Duplicate entry '1000-?.\x18\xb1\xd3\xe0CO\x05\x8b\xf80\xd7E5\xbb' for key 'job_id'", 25, 26, 'invalid start byte'))
            //#
            //            //  If it weren't for this possible Unicode translation error, we
            //            //  could watch for only the exceptions we want, like this:
            //            //  except pymysql.IntegrityError, e:
            //            //    if e.args[0] != mysqlerrors.DUP_ENTRY:
            //            //      raise
            //            if ("Duplicate entry" not in str(e))
            //          {
            //                raise;
            //            }

            //            // NOTE: duplicate entry scenario: however, we can't discern
            //            // whether it was inserted by another process or this one, because an
            //            // intermittent failure may have caused us to retry
            //            this._logger.info('Model insert attempt failed with DUP_ENTRY: '

            //                              'jobID=%s; paramsHash=%s OR particleHash=%s; %r',
            //                              jobID, paramsHash.encode('hex'),
            //                              particleHash.encode('hex'), e);
            //        }
            //        else
            //        {
            //            if (numRowsAffected == 1)
            //            {
            //                // NOTE: SELECT LAST_INSERT_ID() returns 0 after re-connection
            //                conn.cursor.execute('SELECT LAST_INSERT_ID()');
            //                modelID = conn.cursor.fetchall()[0][0];
            //                if (modelID != 0)
            //                {
            //                    return (modelID, True);
            //                }
            //                else
            //                {
            //                    this._logger.warn(
            //                      'SELECT LAST_INSERT_ID for model returned 0, implying loss of '

            //                      'connection: jobID=%s; paramsHash=%r; particleHash=%r',
            //                      jobID, paramsHash, particleHash);
            //                }
            //            }
            //            else
            //            {
            //                this._logger.error(
            //                  'Attempt to insert model resulted in unexpected numRowsAffected: '

            //                  'expected 1, but got %r; jobID=%s; paramsHash=%r; '

            //                  'particleHash=%r',
            //                  numRowsAffected, jobID, paramsHash, particleHash);
            //            }
            //        }

            //        // Look up the model and discern whether it is tagged with our conn id
            //        row = findExactMatchNoRetries(conn);
            //        if (row is not None)
            //        {
            //            (modelID, connectionID) = row;
            //            return (modelID, connectionID == this._connectionID);
            //        }

            //        // This set of params is already in the table, just get the modelID
            //        query = 'SELECT (model_id) FROM %s ' \
            //                '                  WHERE job_id=%%s AND ' \
            //                '                        (_eng_params_hash=%%s ' \
            //                '                         OR _eng_particle_hash=%%s) ' \
            //                '                  LIMIT 1 ' \
            //                % (this.modelsTableName,);
            //        sqlParams = [jobID, paramsHash, particleHash];
            //        numRowsFound = conn.cursor.execute(query, sqlParams);
            //        assert numRowsFound == 1, (
            //          'Model not found: jobID=%s AND (paramsHash=%r OR particleHash=%r); '
            //          'numRowsFound=%r') % (jobID, paramsHash, particleHash, numRowsFound);
            //        (modelID,) = conn.cursor.fetchall()[0];
            //        return (modelID, False);
            //        }
            //    }


            return new Tuple<ulong, bool>(newModel.model_id, true);
        }

        /// <summary>
        /// Update the results string, and/or num_records fields of
        /// a model.This will fail if the model does not currently belong to this
        /// client (connection_id doesn't match).
        /// </summary>
        /// <param name="modelId"></param>
        /// <param name="results"></param>
        /// <param name="metricValue"></param>
        /// <param name="numRecords"></param>
        public override void modelUpdateResults(ulong? modelId, string results = null, double? metricValue = null, uint? numRecords = null)
        {
            var model = Models.Single(m => m.model_id == modelId.GetValueOrDefault());
            model._eng_last_update_time = DateTime.Now;
            model.update_counter += 1;

            if (results != null) model.results = results;
            if (numRecords.HasValue) model.num_records = numRecords.Value;
            if (metricValue.HasValue) model.optimized_metric = metricValue.Value;
        }

        public override void modelUpdateTimestamp(ulong? modelId)
        {
            modelUpdateResults(modelId);
        }

        /// <summary>
        /// Mark a model as completed, with the given completionReason and
        /// completionMsg.This will fail if the model does not currently belong to this
        /// client (connection_id doesn't match).
        /// </summary>
        /// <param name="modelID"></param>
        /// <param name="completionReason"></param>
        /// <param name="completionMsg"></param>
        /// <param name="cpuTime"></param>
        public override void modelSetCompleted(ulong? modelID, string completionReason, string completionMsg, long? cpuTime = null)
        {
            if (string.IsNullOrWhiteSpace(completionMsg)) completionMsg = String.Empty;

            var model = Models.Single(m => m.model_id == modelID.GetValueOrDefault());

            model.status = STATUS_COMPLETED;
            model.completion_reason = completionReason;
            model.completion_msg = completionMsg;
            model.end_time = DateTime.Now;
            model.cpu_time = cpuTime.GetValueOrDefault(0);
            model._eng_last_update_time = DateTime.Now;
            model.update_counter += 1;
        }

        /// <summary>
        /// Fetch all the modelIDs that correspond to a given jobID; empty sequence if none
        /// </summary>
        /// <param name="jobId"></param>
        /// <returns></returns>
        public override List<ulong> jobGetModelIDs(uint? jobId)
        {
            var rows = _getMatchingRowsWithRetries(Models, m => m.job_id == jobId.GetValueOrDefault(), m=>m.model_id);
            return rows;
        }

        /// <summary>
        /// Gets the specified fields for all the models for a single job. This is similar to modelsGetFields
        /// </summary>
        /// <param name="jobId">jobID for the models to be searched</param>
        /// <param name="fields">A list  of fields to return</param>
        /// <param name="ignoreKilled">(True/False). If True, this will ignore models that have been killed</param>
        /// <returns>
        /// a (possibly empty) list of tuples as follows
        /// [
        ///     (model_id1, [field1, ..., fieldn]),
        ///     (model_id2, [field1, ..., fieldn]),
        ///     (model_id3, [field1, ..., fieldn])
        ///     ...
        /// ]
        /// 
        /// NOTE: since there is a window of time between a job getting inserted into
        /// jobs table and the job's worker(s) starting up and creating models, an
        /// empty-list result is one of the normal outcomes.
        /// </returns>
        public override List<Tuple<ulong?, object[]>> modelsGetFieldsForJob(uint? jobId, string[] fields, bool ignoreKilled = false)
        {
            Debug.Assert(fields.Length >= 1, "fields empty");

            var models = Models.Where(m => m.job_id == jobId.GetValueOrDefault()).ToList();

            List<Tuple<ulong?, object[]>> retVal = new List<Tuple<ulong?, object[]>>();

            foreach (var model in models)
            {
                int index = 0;
                Tuple<ulong?, object[]> item = new Tuple<ulong?, object[]>(model.job_id, new object[fields.Length]);

                foreach (var field in fields)
                {
                    if (field == "params")
                    {
                        item.Item2[index++] = model.@params;
                    }
                    else { throw new InvalidOperationException($"field {field} not known");}
                }

                retVal.Add(item);
            }

            return retVal;
        }

        #endregion

        private List<T> _getMatchingRowsWithRetries<T>(List<ModelTable> models, Func<ModelTable, bool> fieldsToMatch, Func<ModelTable, T> selectFieldNames, 
            int? maxRows = null)
        {
            try
            {
                return _getMatchingRowsNoRetries(models, fieldsToMatch, selectFieldNames);
            }
            catch
            {
                return _getMatchingRowsNoRetries(models, fieldsToMatch, selectFieldNames);
            }
        }

        private List<T> _getMatchingRowsNoRetries<T>(List<ModelTable> models, Func<ModelTable, bool> fieldsToMatch, Func<ModelTable, T> selectFieldNames,
            int? maxRows = null)
        {
            Debug.Assert(fieldsToMatch != null);

            var query = models.Where(fieldsToMatch).Select(selectFieldNames);
            if (maxRows.HasValue && maxRows.Value > 0)
            {
                query = query.Take(maxRows.Value);
            }
            return query.ToList();
        }
    }

    public class JobTable
    {
        // (status, client, client_info, client_key, cmd_line, params, 
        // job_hash, _eng_last_update_time, minimum_workers, maximum_workers, priority, _eng_job_type
        /**
        'job_id                  INT UNSIGNED NOT NULL AUTO_INCREMENT',
            // unique jobID
        'client                  CHAR(%d)' % (this.CLIENT_MAX_LEN),
            // name of client (UI, StrmMgr, etc.)
        'client_info             LONGTEXT',
            // Arbitrary data defined by the client
        'client_key             varchar(255)',
            // Foreign key as defined by the client.
        'cmd_line                LONGTEXT',
            // command line to use to launch each worker process
        'params                  LONGTEXT',
            // JSON encoded params for the job, for use by the worker processes
        'job_hash                BINARY(%d) DEFAULT NULL' % (this.HASH_MAX_LEN),
            // unique hash of the job, provided by the client. Used for detecting
            // identical job requests from the same client when they use the
            // jobInsertUnique() method.
        'status                  VARCHAR(16) DEFAULT "notStarted"',
            // One of the STATUS_XXX enumerated value strings
        'completion_reason       VARCHAR(16)',
            // One of the CMPL_REASON_XXX enumerated value strings.
            // NOTE: This is the job completion reason according to the hadoop
            // job-tracker. A success here does not necessarily mean the
            // workers were "happy" with the job. To see if the workers
            // failed, check the worker_completion_reason
        'completion_msg          LONGTEXT',
            // Why this job completed, according to job-tracker
        'worker_completion_reason   VARCHAR(16) DEFAULT "%s"'  % \
                  this.CMPL_REASON_SUCCESS,
            // One of the CMPL_REASON_XXX enumerated value strings. This is
            // may be changed to CMPL_REASON_ERROR if any workers encounter
            // an error while running the job.
        'worker_completion_msg   LONGTEXT',
            // Why this job completed, according to workers. If
            // worker_completion_reason is set to CMPL_REASON_ERROR, this will
            // contain the error information.
        'cancel                  BOOLEAN DEFAULT FALSE',
            // set by UI, polled by engine
        'start_time              DATETIME DEFAULT 0',
            // When job started
        'end_time                DATETIME DEFAULT 0',
            // When job ended
        'results                 LONGTEXT',
            // JSON dict with general information about the results of the job,
            // including the ID and value of the best model
            // TODO: different semantics for results field of ProductionJob
        '_eng_job_type           VARCHAR(32)',
            // String used to specify the type of job that this is. Current
            // choices are hypersearch, production worker, or stream worker
        'minimum_workers         INT UNSIGNED DEFAULT 0',
            // min number of desired workers at a time. If 0, no workers will be
            // allocated in a crunch
        'maximum_workers         INT UNSIGNED DEFAULT 0',
            // max number of desired workers at a time. If 0, then use as many
            // as practical given load on the cluster.
        'priority                 INT DEFAULT %d' % this.DEFAULT_JOB_PRIORITY,
            // job scheduling priority; 0 is the default priority (
            // ClientJobsDAO.DEFAULT_JOB_PRIORITY); positive values are higher
            // priority (up to ClientJobsDAO.MAX_JOB_PRIORITY), and negative
            // values are lower priority (down to ClientJobsDAO.MIN_JOB_PRIORITY)
        '_eng_allocate_new_workers    BOOLEAN DEFAULT TRUE',
            // Should the scheduling algorithm allocate new workers to this job?
            // If a specialized worker willingly gives up control, we set this
            // field to FALSE to avoid allocating new workers.
        '_eng_untended_dead_workers   BOOLEAN DEFAULT FALSE',
            // If a specialized worker fails or is killed by the scheduler, we
            // set this feild to TRUE to indicate that the worker is dead
        'num_failed_workers           INT UNSIGNED DEFAULT 0',
            // The number of failed specialized workers for this job. If the
            // number of failures is >= max.failed.attempts, we mark the job
            // as failed
        'last_failed_worker_error_msg  LONGTEXT',
            // Error message of the most recent specialized failed worker
        '_eng_cleaning_status          VARCHAR(16) DEFAULT "%s"'  % \
                  this.CLEAN_NOT_DONE,
            // Has the job been garbage collected, this includes removing
            // unneeded // model output caches, s3 checkpoints.
        'gen_base_description    LONGTEXT',
            // The contents of the generated description.py file from hypersearch
            // requests. This is generated by the Hypersearch workers and stored
            // here for reference, debugging, and development purposes.
        'gen_permutations        LONGTEXT',
            // The contents of the generated permutations.py file from
            // hypersearch requests. This is generated by the Hypersearch workers
            // and stored here for reference, debugging, and development
            // purposes.
        '_eng_last_update_time   DATETIME DEFAULT 0',
            // time stamp of last update, used for detecting stalled jobs
        '_eng_cjm_conn_id        INT UNSIGNED',
            // ID of the CJM starting up this job
        '_eng_worker_state       LONGTEXT',
            // JSON encoded state of the hypersearch in progress, for private
            // use by the Hypersearch workers
        '_eng_status             LONGTEXT',
            // String used for status messages sent from the engine for
            // informative purposes only. Usually printed periodically by
            // clients watching a job progress.
        '_eng_model_milestones   LONGTEXT',
            // JSon encoded object with information about global model milestone
            // results*/

        public JobTable()
        {
            status = "notStarted";
        }

        public uint jobID { get; set; }
        public string client { get; set; }
        public string client_info { get; set; }
        public string client_key { get; set; }
        public string cmd_line { get; set; }
        public string @params { get; set; }
        public string job_hash { get; set; }
        public string status { get; set; }
        public string completion_reason { get; set; }
        public string completion_msg { get; set; }
        public string worker_completion_reason { get; set; }
        public string worker_completion_msg { get; set; }
        public bool cancel { get; set; }
        public DateTime start_time { get; set; }
        public DateTime end_time { get; set; }
        public string results { get; set; } // Dictionary<string,object> json
        [MaxLength(32)]
        public string _eng_job_type { get; set; }
        public int minimum_workers { get; set; }
        public int maximum_workers { get; set; }
        public int priority { get; set; }
        public bool _eng_allocate_new_workers { get; set; }
        public bool _eng_untended_dead_workers { get; set; }
        public int num_failed_workers { get; set; }
        public string last_failed_worker_error_msg { get; set; }
        [MaxLength(16)]
        public string _eng_cleaning_status { get; set; }
        public string gen_base_description { get; set; }
        public string gen_permutations { get; set; }

        public DateTime _eng_last_update_time { get; set; }
        public int _eng_cjm_conn_id { get; set; }
        public string _eng_worker_state { get; set; }
        public string _eng_status { get; set; }
        public string _eng_model_milestones { get; set; }

        public NamedTuple ToNamedTuple()
        {
            NamedTuple tuple = new NamedTuple(GetPropertyKeys(), GetPropertyValues());
            return tuple;
        }

        private object[] GetPropertyValues()
        {
            return this.GetType().GetProperties().Select(p => p.GetValue(this)).ToArray();
        }

        private string[] GetPropertyKeys()
        {
            return this.GetType().GetProperties().Select(p =>
            {
                string dbName = p.Name;
                string[] words = dbName.Split(new[] { '_' }, StringSplitOptions.RemoveEmptyEntries);
                //if (dbName.StartsWith("_"))
                //{
                //    words = words.Skip(1).ToArray();
                //}
                List<string> pubWords = new List<string> { words[0] };
                foreach (var word in words.Skip(1))
                {
                    pubWords.Add(char.ToUpper(word[0]) + new string(word.Skip(1).ToArray()));
                }
                return string.Join("", pubWords);
            }).ToArray();
        }
    }

    public class ModelTable
    {
        public ModelTable()
        {
            status = "notStarted";
        }
        public ulong model_id { get; set; }
        public uint job_id { get; set; }
        public string @params { get; set; } // ModelParams serialized
        public string status { get; set; }
        public string completion_reason { get; set; }
        public string completion_msg { get; set; }
        public string results { get; set; } // Tuple serialized - Map<string,double?> /  Map<string,double?>
        public double? optimized_metric { get; set; }
        public uint update_counter { get; set; }
        public uint num_records { get; set; }
        public DateTime start_time { get; set; }
        public DateTime end_time { get; set; }
        public double cpu_time { get; set; }
        public string model_checkpoint_id { get; set; }
        public string gen_description { get; set; }
        public string _eng_params_hash { get; set; }
        public string _eng_particle_hash { get; set; }
        public DateTime _eng_last_update_time { get; set; }
        public string _eng_task_tracker_id { get; set; }
        public string _eng_worker_id { get; set; }
        public string _eng_attempt_id { get; set; }
        public string _eng_worker_conn_id { get; set; }
        public string _eng_milestones { get; set; }
        public string _eng_stop { get; set; }
        public bool _eng_matured { get; set; }

        /*
        'model_id                BIGINT UNSIGNED NOT NULL AUTO_INCREMENT',
            // globally unique model ID
        'job_id                  INT UNSIGNED NOT NULL',
            // jobID
        'params                  LONGTEXT NOT NULL',
            // JSON encoded params for the model
        'status                  VARCHAR(16) DEFAULT "notStarted"',
            // One of the STATUS_XXX enumerated value strings
        'completion_reason       VARCHAR(16)',
            // One of the CMPL_REASON_XXX enumerated value strings
        'completion_msg          LONGTEXT',
            // Why this job completed
        'results                 LONGTEXT DEFAULT NULL',
            // JSON encoded structure containing metrics produced by the model
        'optimized_metric        FLOAT ',
            #Value of the particular metric we are optimizing in hypersearch
        'update_counter          INT UNSIGNED DEFAULT 0',
            // incremented by engine every time the results is updated
        'num_records             INT UNSIGNED DEFAULT 0',
            // number of records processed so far
        'start_time              DATETIME DEFAULT 0',
            // When this model started being evaluated
        'end_time                DATETIME DEFAULT 0',
            // When this model completed
        'cpu_time                FLOAT DEFAULT 0',
            // How much actual CPU time was spent on this model, in seconds. This
            //  excludes time the process spent sleeping, or otherwise not
            //  actually executing code.
        'model_checkpoint_id     LONGTEXT',
            // Checkpoint identifier for this model (after it has been saved)
        'gen_description         LONGTEXT',
            // The contents of the generated description.py file from hypersearch
            // requests. This is generated by the Hypersearch workers and stored
            // here for reference, debugging, and development purposes.
        '_eng_params_hash        BINARY(%d) DEFAULT NULL' % (this.HASH_MAX_LEN),
            // MD5 hash of the params
        '_eng_particle_hash      BINARY(%d) DEFAULT NULL' % (this.HASH_MAX_LEN),
            // MD5 hash of the particle info for PSO algorithm
        '_eng_last_update_time   DATETIME DEFAULT 0',
            // time stamp of last update, used for detecting stalled workers
        '_eng_task_tracker_id    TINYBLOB',
            // Hadoop Task Tracker ID
        '_eng_worker_id          TINYBLOB',
            // Hadoop Map Task ID
        '_eng_attempt_id         TINYBLOB',
            // Hadoop Map task attempt ID
        '_eng_worker_conn_id     INT DEFAULT 0',
            // database client connection ID of the worker that is running this
            // model
        '_eng_milestones         LONGTEXT',
            // A JSON encoded list of metric values for the model at each
            //  milestone point
        '_eng_stop               VARCHAR(16) DEFAULT NULL',
            // One of the STOP_REASON_XXX enumerated value strings. Set either by
            // the swarm terminator of either the current, or another
            // Hypersearch worker.
        '_eng_matured            BOOLEAN DEFAULT FALSE',
            // Set by the model maturity-checker when it decides that this model
            //  has "matured". This means that it has reached the point of
            //  not getting better results with more data.
        */
    }

    public class ResultAndStatusModel
    {
        public ulong modelId;
        public Tuple results; // (Map<string, double?>, (Map<string, double?>
        public string resultsSerialized;
        public string status;
        public uint updateCounter;
        public uint numRecords;
        public string completionReason;
        public string completionMsg;
        public bool engMatured;
        public string engParamsHash;
    }
}
